<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[计算素数个数的三段进阶]]></title>
    <url>%2F2018%2F07%2F04%2Fcount-primes-think%2F</url>
    <content type="text"><![CDATA[今天坐leetcode上的Count Primes这道题，题目要求比较的简单：Count the number of prime numbers less than a non-negative number, n. 就是给一个数字，然后输出从0到这个数字内有多少个素数。老办法先实现后优化，实现之后发现优化真不容易，借助外界各种资源后，差不多算是达到了自己想达到的效果，故记录一下此次一波三折的优化。 低阶版1234567891011121314151617function isPrimes(num) &#123; for(var j = 2; j &lt;= Math.sqrt(num); j++) &#123; if(num % j == 0)&#123; return false &#125; &#125; return true&#125;var countPrimes = function(n) &#123; var coun = 0 for(var i =2; i &lt; n; i++) &#123; if(isPrimes(i)) &#123; coun++ &#125; &#125; return coun&#125;; 我们可以看到函数逻辑比较简单，内层isPrimes函数为了提高速度，给除数加了一个小于等于Math.sqrt(num)的限制，之所以可以用这个数字来做限制是因为：num = a * b 当a增大的时候b一定减小，我们假设a从1一直增加，那么b将从num一直减小，当到a = Math.sqrt(num)的时候，a == b ，如果此时a继续增大呢，a是不是就向刚才一直减小的b一样了，也就是说我们相当于把之前做的运算又从新做了一遍，而这个计算是没有意义的，所以如果一个数除到他的开跟都不能整除，基本可以判定他是一个素数了。 进阶版12345678910111213141516171819var primesList = [] function isPrimes(num) &#123; for(var j = 0; primesList[j] &lt;= Math.sqrt(num); j++) &#123; if(num % primesList[j] == 0)&#123; return false &#125; &#125; return true&#125;var countPrimes = function(n) &#123; var coun = 0 for(var i =2; i &lt; n; i++) &#123; if(isPrimes(i)) &#123; primesList.push(i) //给数组添加质数，丰富质数表 coun++ &#125; &#125; return coun&#125;; 我们看一下上面的函数，上面函数的思路是这样的：一个数（大于1），他不是质数（素数）就是合数，合数可以分解成几个质数相乘，那么我是不是只要用这个数去除以质数我就知道他是不是一个合数了，那么问题来看了，一个数我们记作A，我们只需要依次他除以[2,√A]之间的质数就能判断出来他是不是一个合数了，这样子比我们从[2,√A]，一个一个除要快很多，好了现在问题来了，我们是不是需要一个[2,√A]之间的质数表，上面的程序是这样子构建这个质数表的，从2开始，一边判断一边添加，这样子后面的数字就可以用前面的质数表了（实际上一个质数的平方是远大于紧跟在在后面的那个质数的），我们现在回到程序（其实单步跟一下程序就能看出来啦）。1234if(isPrimes(i)) &#123; primesList.push(i) //给数组添加质数，丰富质数表 coun++&#125;1 这个语句作用是，如果发现一个数是质数就给他放到质数表里，然后在记数结果+112345678function isPrimes(num) &#123; for(var j = 0; primesList[j] &lt;= Math.sqrt(num); j++) &#123; if(num % primesList[j] == 0)&#123; return false &#125; &#125; return true&#125; 这个函数是判断函数啦，需要注意的是，第一次计算的时候primesList[0] == undefine ,num % primesList[j]的结果是NAN(我更喜欢叫他是无意义的计算)，然后NAN !== 0 （NAN连自己都相等） 这样子第一质数2，就成功的放入了数组啦我们又成功地优化了函数，不禁要问这样子还可以优化吗？答案是：必须可以啊。 进阶版小优化我们给上面函数的 countPrimes 函数改一下12345678910var countPrimes = function(n) &#123; var coun = 1 for(var i =3; i &lt; n; i+=2) &#123; if(isPrimes(i)) &#123; primesList.push(i) //给数组添加质数，丰富质数表 coun++ &#125; &#125; return coun&#125;;我们把coun 初始值改成1，变量i从3开始，每次都往里放奇数（偶数绝逼是合数），这样子速度又快了不少 再进阶版虽然上面的好理解，而且有了一定的优化，但是效率并不高，那么有没有效率更高的呢，答案是必须的，我们来看一下几千年前的一个算法：埃拉托斯特尼筛法其实 埃拉托斯特尼筛法 简单的说就是，把[2,A]之间的[2,√A]的数的所有倍数全部划去，最后留下的就是质数。那么我们是不是可以这样子生成一个大小为n的数组，数组全部都为1，每发现一个合数，我们就把一个数组的元素变为0，最后我们只需要统计1的个数就好了12345678910111213141516171819202122232425function countPrimes(n) &#123; //我们声明一个大小为n的数组，并且全部标记为1（我们把标记1是质数，0标记合数）， var flags = new Array(n).fill(1) //其实这里的想法是 0 1 全不是质数，所以打掉， flags[0] = flags[1] = 0 var sn = Math.sqrt(n) //我们只比对到[2,√A]的所有倍数 for(var i = 2; i &lt;= sn; i++) &#123; //注意在循环里面我们已经操作了flags，所以我们此时不需要再判断划掉了的元素（flags[i] == 0） if (flags[i]) &#123; //注意我们这个j，埃拉托斯特尼筛法 是从数字的倍数开始划的 for(var j = i * i; j &lt; n; j += i) &#123; flags[j] = 0 &#125; &#125; &#125; var count = 0 for(var i = 0; i&lt;n; i++) &#123; if(flags[i]) &#123; count++ &#125; &#125; return count&#125;现在我们又GET了一个新技能，我们再想一下是不是还可以优化一下，答案依然是是的，我们看一下他的进阶版 再再进阶版如果你有心的话，你会发现我们上一个版本的函数，在划去合数的时候，会有重复划去的过程，这个我也就不上图了，自己单步走一下，或者在纸上画一下一切就会浮现出来的。我们先上函数12345678910111213141516171819202122//小于3 就是 0 1 直接标记为0var countPrimesx = function(n) &#123; if (n &lt; 3) &#123; return 0 &#125; //数组全部置1 var f = new Array(n).fill(true)//有一半的数字为偶数，所以直接打掉一半，然后后面的或是为了取整 var count = n / 2 | 0 for(var i = 3; i * i &lt; n; i += 2) &#123; for(var j = i * i; j &lt; n; j += 2*i) &#123; if (f[j]) &#123; --count f[j] = false &#125; &#125; &#125; return count&#125; 文章末尾感谢那些愿意分享知识的人：谢大喵TanX的博客]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leet</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的递归以及浅谈尾调用]]></title>
    <url>%2F2018%2F07%2F03%2FJavaScript-tail-Call%2F</url>
    <content type="text"><![CDATA[一个递归引发的血案案发现场今天看到了递归，测试的时候必须是经典的 Fibonacci （斐波纳契） 数列,然后我做的时候的代码如下：1234function Fibonacci (n) &#123; if ( n &lt;= 1 ) &#123;return 1&#125;; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;这是一个很简答的递归函数，单纯且不做作。他很简单，看一眼就知道他是如何运算的，单纯到到计算一个Fibonacci(100)就给我来个栈溢出错误(stack overflow)，然后我很奇葩的算了一下Fibonacci(25)，然后就卡-住-了，这不行啊，所以我就去搜原因去咯。 抢救现场找了一下，找了一个有优化效果的函数：尾递归优化后的程序源程序连接1234var fibArr =[0,1,1];function Fibonacci(n)&#123; return fibArr[n]? fibArr[n]:(fibArr[n]=Fibonacci(n-1)+Fibonacci(n-2));&#125; 案件复盘嗯，解释这个程序的思想之前我们先来看一下我们以前的程序都干了什么，在这之前我们先来补充一个小知识点：我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。 @阮一峰es6.ruanyifeng.com/?search=%E9%80%92%E5%BD%92&x=0&y=0#docs/function通过上面我们知道了，要是每次调用都会在内存生成一个调用帧，然后我们看一下Fibonacci数列，我们单步进入程序的时候（或者在纸上画一下）可以发现，我们一开始的程序在计算的时候会压入很多重复的计算，也就是说很多调用帧的返回结果是相同的，但是我们还是把他们压入到了调用栈里面，（函数先计算+左边的，然后就不断的进入函数内部，不断的压栈，计算完成后再一层一层的往回出栈，等到+左边的计算完了，再来右边的，你会发现右边的很多调用帧的结果刚才都算出来了，可是在算+左边结果的时候又把它们清除了，这样子是不是浪费了大把的时间）这样一来就是两个结果，栈不够用爆掉啦，栈将将够用，然后程序慢慢进再慢慢的出，这时候好的电脑运行会变慢，差的电脑就会卡住或者死机，让我哭一会。 引入尾调用我哭好了，我们继续看优化后的函数，优化后的函数优化就是优化了重复的那个一部分，我们用数组来存储+左边我们每一个调用帧计算的结果，到计算+右边的时候我们直接和数组里面的数字（注意那个n）进行比对,准确的说是看参数是否相同，相同的话就直接出返回结果而不进栈了。这里其实用到了一点缓存区的概念（这个我们有空再聊哈），我们这样子优化的直接效果就是进去的调用帧少了，直接结果是栈不会爆了，也没有了多余的重复计算，速度直接就上去了。那么问题来了，是不是递归都会有这个问题，答案是：一些形式的递归是的，这个由JavaScript的栈机制造成的。是不是要说，一些形式是的，那不就是还有形式不是，好了，我要开始装逼了，那个形式就是：尾调用。直接上阮一峰大佬的解释：尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。 123function f(x)&#123; return g(x);&#125;上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。以下三种情况，都不属于尾调用。 12345678910111213141516// 情况一function f(x)&#123; let y = g(x); return y;&#125;// 情况二function f(x)&#123; return g(x) + 1;&#125;// 情况三function f(x)&#123; g(x);&#125;上面代码中，情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。 1234function f(x)&#123; g(x); return undefined;&#125;尾调用不一定出现在函数尾部，只要是最后一步操作即可。 123456function f(x) &#123; if (x &gt; 0) &#123; return m(x) &#125; return n(x);&#125;上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。 @阮一峰es6.ruanyifeng.com/?search=%E9%80%92%E5%BD%92&x=0&y=0#docs/function#%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96 关于尾调用的优化好了现在知道了尾调用，按道理我应该引入尾调用的优化，毕竟ES6第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。也就是说，尾调用是一写法形式，写成这样子，浏览器会自动进行优化（不过目前只有苹果的才支持，其它的浏览器需要在严格模式下才执行这个操作），又或者我们可以写一个函数，自己来做这个尾调用优化，但是我依稀还记得 Eloquent_JavaScript（第二版） 中有一句话：The dilemma of speed versus elegance is an interesting one. You can see it as a kind of continuum between human-friendliness and machinefriendliness. Almost any program can be made faster by making it bigger and more convoluted. The programmer must decide on an appropriate balance. Marijn HaverbekeEloquent_JavaScript其实自己进行优化的方式也只是把递归转化成循环的样子，有的人会坚持尽可能的用循环而不是用递归，应为为达到同样的效果用循环更快，其实二者那个好都说不好的，或许等到浏览器都支持在正常模式下也进行尾递归优化的时候，递归就用的越来越多了，毕竟他有其独到的优势哈。 递归函数的规则最后附上一个写递归函数的规则：当编写递归例程的时候，关键是要牢记递归的四条基本法则: 基准情形。必须总有某些基准情形，它无须递归就能解出。 不断推进。对于那些需要递归求解的情形嗯每一次递归调用都必须要使求解状况朝接近基准情形的方向推进。 设计法则。假设所有的递归调用都能运行。 合成效益法则(ωmpound interest rule ) 。在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。 Mark Allen Weiss·著 冯舜玺·译数据结构与算法分析：C语言描述（第2版） 以下是本博文参考的资料，感谢他们的分享 数据结构与算法分析：C语言描述（第2版）阮一峰大佬的：ECMAScript 6入门phpstudy的文章jxgz_leo的博客。关于尾数调用优化，这个博文写的比阮大佬能详细]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>递归</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发现个异或的妙用]]></title>
    <url>%2F2018%2F07%2F02%2FSingle-Number%2F</url>
    <content type="text"><![CDATA[有个题目是这样子的：Single Number题目要求如下：Given a non-empty array of integers, every element appears twice except for one. Find that single one.Note:Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?意思就是一个数组[2，2，3，3，5] 5就是那个 single numble了然后自己想了半天也就会笨办法，倒也能通过，然后看了一下前面人的解法,又一次打开了脑洞大佬的代码如下：12345678910var singleNumber = function(nums) &#123; if (!nums || nums.length === 0) &#123; throw new Error(); &#125; var res = nums[0]; for (var i = 1; i &lt; nums.length; i++) &#123; res ^= nums[i]; &#125; return res;&#125;;一开始我还没有看懂为什么异或就可以，不就是相同为0，不同为1啊，然后单步进去运行了一下，还是一头雾水（单步的时候res没有规律），出去上个厕所，喝口水。然后突然想到，从把数组所有的数字全拿出来，一个一个异或，可以看成相同的和相同的异或，然后得到的是0 ，最后剩下一个奇数的single number，把他和0异或（^）就得到他本身啊。 多动动，多喝水，没事上个厕所，买个小黄鸭，换个角度，问题就迎刃而解啊啊啊啊啊啊！！！！]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>思路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从Power_of_Two所得]]></title>
    <url>%2F2018%2F07%2F02%2Fleetode-Power-of-Two-think%2F</url>
    <content type="text"><![CDATA[开始刷leetcode上的题目了，毕竟写程序也是需要开脑洞的，刷题目就能让自己脑洞越来越大的说，这不发现了一个题目： Power of Two题目要求：Given an integer, write a function to determine if it is a power of two.其实就是让你看一个数是不是2的幂次方 先说我的思路吧，一个数一直除以2，除到他小于4的时候，2的幂方数就是只有 2 1 这两个数字了，那么我判断一下是不是他俩就好啦123456789101112131415161718192021var isPowerOfTwo = function (n) &#123; var wx = n var falg = 0 while (falg == 0) &#123; // wx = wx &gt;&gt; 1 wx = wx / 2 if (wx &lt; 4) &#123; //需要考虑一开始就是1的情况 if (wx == 2 || wx == 1 || wx == 0.5) &#123; falg = 1 // console.log("true") return true &#125; else &#123; falg = 2 // console.log("false") return false &#125; &#125; &#125;&#125;; 然后看了看别人的代码，发现了一个很棒的思路，思路就是看 n 与 n-1 与出来的结果是不是 0我们看一下 4 二进制是：0100 那么3呢，3是 0011，二者与出来就是0，所以这个思路太赞了，一下子就得出结果了。代码是没有的，思路都有了，代码还写不出来吗！ 又发现了个看数字是不是4的幂的题我的想法是 先看他是不是2的幂，再看他是不是小于10，小于的话，等不等于 4 或者 8然后发现了一个想法是，先看是不是2 的幂，然后看能不能整除4然后又发现了个是不是3的幂的数，我的思路是利用数学规则（各个位相加为三的倍数）看他是不是能被3整除，能的话就除以3，用结果继续这样子判断，一直到他小于10的时候，看是不是 3 或者 9结果发现了一个更惊为天人的思路，思路是这样子的，把可以取值范围内的最大3的幂数求出来，记为 a , 然后给个数字b 如果 a % b === 0那b就是3的幂数，没有想到的话看下面123a = 3 * 3 * 3 * 3 * 3 *3 *3 b = 3 * 3 * 3 c = 3 * 3 * 4 这个就很直观了吧！]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>思路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给文章加入版权信息]]></title>
    <url>%2F2018%2F07%2F02%2Ftip-copyright%2F</url>
    <content type="text"><![CDATA[看到别人的的博客下面都有版权信息（就是本文最底下的那个啦），然后自己也想加上一个，搜了一下都是17年的老文章，用的是自定义的方法。本来打算去DIY一下，然后突发奇想去主题插件搜了一下版权（copyright），然后发现了这个东西123post_copyright: enable: false..... 就把那个enable: false 改成enable: true 就好啦` ps:如果底下的版权信息中的本文链接：成了http://yoursite.com/2018/07/02/tip-copyright这个样子只需要在网站配置文件下把url: http://yoursite.com 改成url: https://fengmumu1.github.io 就好啦 有一篇博文还可以，就是关于next配置的，不过文章写的时间有点老，方法都还是有效果的，不过新的next版本会有更好的实现方式，所以不要以为的抄啦。 文章传送门]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的数字存储]]></title>
    <url>%2F2018%2F06%2F30%2Fjs-number%2F</url>
    <content type="text"><![CDATA[JavaScript中数字是不区分整数值与浮点数值的，在JavaScript中所有的数均使用64位的浮点格式来存储以及表示（IEEE 754标准）。所以数值最大是：±1.7976931348623157 X 10^308最小是±5X10^-324，可以表示的整数范围是-9 007 199 254 740 992~9 007 199 254 740 992 （对应的是-2^53~2^53）包含边界值。注意：在对JS中的数值进行位操作的时候会自动把64位转化为32进行操作（由于运算符的自身限制，其只能对32位进行操作），在对小数进行位操作 比如左移零位，小数会丢弃小数部分转化成整数 JavaScript中数字不一定很准确首先我们先看一段代码123456var x = 0var y = 0x = .3 - .2y = .2 - .1console.log(x == .1 )console.log(y == .1 )运行结果是 false 和 true讲道理的说0.3 - 0.2 = 0.1;0.2-0.1 = 0.1 这个是正确的，那么为什么到了JS的代码里就不正确了，解决这个问题，我们首先要看一下JS的数字是如何存储的。 JS数字的存储在本文的前言中我们说到了JS用的是IEEE754标准，这个标准规定了浮点数的表示方法（此方法也是目前通用计算机所才用的浮点数存数方式）。在此标准中浮点数有float和double两种存储形式，但由于JS是一种弱类型编程语言他的数字采用了double类型存储，也就是我们常说的使用64位来存储数字的双精度型。那么我们是如何利用这64位来存储数据的呢？ 我们都知道科学计数法，即把一个数比如123465.555可以写成1.2345655510^5，这样子不仅读写方便也能减少存数该数字的空间，123456.555是一个十进制的数字，那么我们是把一个二进制的数字是否也可以转化成这个形式，以达到减少存数空间的目的，答案是肯定的。我们把一个十进制数比如：3.25 写成二进制的形式：11001.01，类比十进制的写法，我们可以把他写成 **1.100101\2^4，现在我们看一下这个数字，他由有效数字 1.100101 以及指数 2^4** 以及我们省略了的符号位组成（正数的符号位是 + 负数的是- 零的话严格来说不属于正负，计算机如何处理他我们后文将解释），那么64位的空间我们就知道需要放三大块的东西了：有效数字、指数、符号位 sign bit(符号）：我们在64位的最高位放置符号位，最高位为1，表示数字是正数还是负数 exponent(指数):我们在从左往右再取11位用来表示指数 mantissa(尾数):我们把剩余的52位空间全部用来存储有效数字 1.为了最大限度的利用存储有效数字的52位，我们把小数点以及小数点前的那一个数字给省略掉（正确的化简后尾数会被处理到大于等于1而小于2的区间内，这时候便可省去前导的“1”），所以我们只需要存贮小数点后面的 100101就可以了2.在上图中存储指数的数值叫做阶码，有它转换出来的阶码的数值等于指数的数值，阶码=指数+1023 (科学计数法中的指数是可以为负数的，所以约定减去一个中间数 1023，[0,1022] 表示为负，[1024,2047] 表示为正)。在 ECMAScript 规范里有给出指数的范围： [-1074, 971] 。 为什么会出现数字不准确现在我们知道了一个数是如何存储的，那么我们来想一个问题，1.3转化为二进制是多少0.010011001100....1100，对的你发现了他的小数部分除不尽，那么意味着他的小数部分用64位表示不完。我们来看一下浏览器是如何处理的。12var a = 1.3 console.log(a.toString(2)) 输出的结果是 1.010011001100110011001100110011001100110011001100110011我们来比较一下浏览器计算的1.3和我们手算的1.3的差别12浏览器： 1.0100110011001100110011001100110011001100110011001101手 算 ： 1.0100110011001100110011001100110011001100110011001100*1100* 我们看到浏览器进行了进位操作，浏览器执行的是满1进位，不满则省略的方案所以这也就是为什么我们在进行浮点数运算的时候有时候得不到精确的数值的原因所在了。 为什么 0.3 == 0.312var x = 0.3console.log( x === 0.3 ) 它的运行结果是true前面不是说使用浮点数存储，小数部分出现循环后，系统存的不是一个准确数值，那么这里为什么会是true呢？因为 尾数(mantissa) 固定长度是 52 位，再加上省略的一位，最多可以表示的数是 2^53=9007199254740992，对应科学计数尾数是 9.007199254740992，这也是 JS 最多能表示的精度（也就是说按照52个尾数全为0到其全为1，让其对应以十进制表示的从1到9007199254740992[注意我们省略了小数点前面的一位，所以计算的时候应该按照53位计算]）。它的长度是 16，所以可以近似使用 toPrecision(16) 来做精度运算，超过的精度会自动做凑整处理。于是就有 x.toPrecision(16) === 0.3toPrecision(16) 是先把二进制保存的不精确的那个数，转化为十进制数。然后是对十进制的数字再去保留小数点后的16位 大数危机如果有数字处于2^53到2^63之间呢，他们是是如何取舍的 (2^53, 2^54) 之间的数会两个选一个，只能精确表示偶数 (2^54, 2^55) 之间的数会四个选一个，只能精确表示4个倍数… 依次跳过更多2的倍数我们来看一张图（图是我偷得） 我们可以看到在中间的部分，实数与浮点数还可以近似的一一对应，越往两边用浮点数与实数对应关系就越差，也就是说精度就逐渐的丢失 要想解决大数的问题你可以引用第三方库bignumber.js，原理是把所有数字当作字符串，重新实现了计算逻辑，缺点是性能比原生的差很多，所以原生支持大数就很有必要了。TC39 已经有一个 Stage 3 的提案proposal bigint，大数问题有望彻底解决。在浏览器正式支持前，可以使用Babel 7.0 来实现，它的内部是自动转换成 big-integer 来计算，这样能保持精度但运算效率会降低。 @camsongzhuanlan.zhihu.com/p/30703042 toPrecision 和 toFixed toPrecision 是处理精度，精度是从左至右第一个不为0的数开始数起。 toFixed 是小数点后指定位数取整，从小数点开始数起。两者都能对多余数字做凑整处理，也有些人用 toFixed 来做四舍五入，但注意它是有坑的。比如1.055.toFixed(2) = 1.05 问题是他的第三位明明是5啊，说好的四舍五入呢？因为1.055实际对应的数字是1.0499999999 所以就出现前面的结果啦当你拿到 1.4000000000000001 这样的数据要展示时，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示。对于运算类操作，如 +-*/，就不能使用 toPrecision 了。正确的做法是把小数转成整数后再运算。ps: 1.以上内容是原文章的删减内容，需要看原文章内容，下面有链接 2.toPrecision 取一个经验数值 12 即可 3.原文推荐了一个js处理浮点数的类库，大小只有1K，传送门: number-precision @camsongzhuanlan.zhihu.com/p/30703042 现在我们继续看这样一行代码19999999999999999 == 10000000000000000 结果是true，这个又是为什么呢？我们在前面说到e的范围是 [-1074, 971] ，也就是说他能保存的最大的数字是1 x (2^53 - 1) x 2^971 = 1.7976931348623157e+308 52个1就等于 2^53 - 1 注意结果要补上我们省略的那个1. 类似的整数部分最小的是：1 x 1 x 2^(-1074) = 5e-324由此我们可以知道：Number.MAX_VALUE 以及 Number.MIN_VALUE 的两个数值了注意：Number.MIN_VALUE 只是正数中最小的数字，实数最小的数字是 -Number.MAX_VALUE 现在结合前面所有的知识回过头来看一下，js中最大的数字是 Number.MAX_VALUE ，他是尾数为 2^53 指数为971 时候的数字那么 如果有个数值他转成二进制的科学计数法之后，尾数大于2^53次方呢，这时候由于计算机会有一定的取舍（前文已经说过，具体的取舍方法有四条，有兴趣的可以自行维基解密），所以他的存储就有了误差。所以经过了取舍的两个大数就相同了， 注意：其实现在我们可以发现在浮点数的时候虽然最大是 Number.MAX_VALUE，但是他有可能是其他的数值取舍得来，所以小于2^53的数值才是可以正确表示的数值，所以就有了 Number.MAX_SAFE_INTEGE 这个数值，其表示js中的安全数值 最后八卦几个数值9007199254740990 (that is, 2^53-2) distinct “Not-a-Number” values of the IEEE Standard are represented in ECMAScript as a single special NaN value. (Note that the NaN value is produced by the program expression NaN.) In some implementations, external code might be able to detect a difference between various Not-a-Number values, but such behaviour is implementation-dependent; to ECMAScript code, all NaN values are indistinguishable from each other. @ECMAScript 规范es5.github.io/#x8.5 NAN = 9007199254740990 == 2^53−2 需要注意,NAN只是数值上是这个，但实际上他是有程序生成的所以所以NAN不等于NANHA 关于无穷大有个有意思的东西首先抛出大佬给的问题（原始博文在最底部）1234567891011Number.MAX_VALUE + 1 == Number.MAX_VALUE;Number.MAX_VALUE + 2 == Number.MAX_VALUE;...Number.MAX_VALUE + x == Number.MAX_VALUE;Number.MAX_VALUE + x + 1 == Infinity;...Number.MAX_VALUE + Number.MAX_VALUE == Infinity; // 问题：// 1. x 的值是什么？// 2. Infinity - Number.MAX_VALUE == x + 1; 是 true 还是 false ? 放出原博主的解答：我的想法是这样的： Number.MAX_VALUE.toString(16) = ”fffffffffffff800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000″ 前面有 13 个 f, 二进制就是 52 个 1还有一个 8, 二进制是 1000也就是说，前面 53 位都是 1 这样，当 Number.MAX_VALUE + 1 时，1 替代最后一个 0，但 IEEE 754 双精度浮点数的 m 最大为 53（含隐藏位），因此添加的 1 在存储时会被舍弃掉，所以： Number.MAX_VALUE + 1 == Number.MAX_VALUE 同理类推，当 8（1000） 变成 b（1011），b 后面的位取最大值时，依旧有： 0xfffffffffffffbffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff == Number.MAX_VALUE 进一步，当 再增 1, b 变成 c 时，将发生质变： 0xfffffffffffffc00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 == Infinity 这是因为前面将有 54 个连续的 1, 在存储时，exponent 将由971 变成 972, 超出了 IEEE 754 双精度浮点数存储格式中 e 的最大值，因此质变为 Infinity 了。 这样，题目中 x 的值就很容易得到了： x = 0xfffffffffffffbffff… – 0xfffffffffffff80000…= 0x00000000000003ffff… 注意这个数在IEEE 754 双精度浮点数格式下无法精确存储。 还能得到两个有趣的结论： Number.MAX_VALUE 不是一个数，而是一个区间 [0xfffffffffffff80000…, 0xfffffffffffffc0000…) Infinity 指的是，所有大于等于 0xfffffffffffffc0000… 的数。 @lifesingerlifesinger.wordpress.com/2011/03/07/js-precision 更新一个知识点： Number.EPSILON 是一个整数，然后与这个整数大的第一个数的差值也就是说如果两个数的差值小于 Number.EPSILON 这两个数就是一个数 参考文档 谢大喵的上课视频 知乎：抓住数据的小尾巴 - JS浮点数陷阱及解法 https://zhuanlan.zhihu.com/p/30703042 lifesinger的博客 https://lifesinger.wordpress.com/2011/03/07/js-precision/ ECMAScript 规范 http://es5.github.io/#x8.5]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数字</tag>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo下的markdown语法]]></title>
    <url>%2F2018%2F06%2F29%2Fhexo-markdown-grammar%2F</url>
    <content type="text"><![CDATA[入坑了一个新的主题-next,发现他有一些markdown的语法比较特殊，所以整理了一下相关的信息。 markdown语法文章头部的 front-matter目前我用的主题是next，版本是：v5.1.4 ,hexo的版本是3.7.1123456title: hexo下的markdown语法date: 2018-06-29 20:53:40tags: - hexo - markdown语法categories: hexo 以前的tages的写法是 tags: [aa,bb,cc] ，现在我发现tages的写法是：隔行然后缩进前面加中划线，再加上一个空格，然后写上标签。注意：tags 与后面的标签内容必须要有一个空格，在hexo中的很多地方都有这个要求 文章相关的语法标题123===== (等于号)是一级标题------ （减号）是二级标题### 是三级标题 或者使用传统的12345# H1## H2### H3...###### H6 分割线单独一行使用***或者——————（下划线） 删除线使用~~需要删除的文字~~来表示，这个要被删除注意：前后~~与文字没有空格 超链接1[链接的文字](链接的地址 &quot;鼠标指上后链接显示的文字&quot;) 注释用\来注释，类似于转义字符的效果 引用1&gt; 打工是不可能打工的，这辈子都不可能打工的 注意：如果仅在第一行使用 &gt;， 后面相邻的行即使省略 &gt;，也会变成引用内容，可以在结束的语句后面加上两个空格，或者与后面的语句直接空一行 验证写法12345&gt; 打工是不可能打工的，这辈子都不可能打工的打工是不可能打工的，这辈子都不可能打工的 打工是不可能打工的，这辈子都不可能打工的 打工是不可能打工的，这辈子都不可能打工的 效果 打工是不可能打工的，这辈子都不可能打工的打工是不可能打工的，这辈子都不可能打工的打工是不可能打工的，这辈子都不可能打工的 打工是不可能打工的，这辈子都不可能打工的推荐使用后面说的内置标签来引入，效果更好使用&gt;的嵌套格式，没有效果 列表列表有无序和有序之分，考虑到用实际使用无序列表居多，这里只介绍无序列表，无序列表使用空格的缩进来表示层级，+和- 都是他的关键字符,此外给-/+ 和文字中间加入 [ ] 可以有计划表的效果写法123456+ 计划A + [ ] A计划第一步 + [x]首先XXX- [ ] 计划B - [ ] B计划第一步 - [x]首先XXX效果 计划A A计划第一步 首先XXX 计划B B计划第一步 首先XXX 注意：关键字符与文字要有空格，[]中间要用空格打开，否则不生效 插入图片1![Alt text](图片链接 &quot;optional title&quot;) Alt text：图片的Alt标签，用来描述图片的关键词，可以不写。最初的本意是当图片因为某种原因不能被显示时而出现的替代文字，后来又被用于SEO，可以方便搜索引擎根据Alt text里面的关键词搜索到图片。 图片链接：可以是图片的本地地址或者是网址。 “optional title”：鼠标悬置于图片上会出现的标题文字，可以不写。 @tahrwww.zhihu.com/question/21065229/answer/132993179 原生的语法使用效果不好，推荐使用后面hexo以及next的插入图片对应标签语法 表格使用|来分隔不同的单元格，使用-来分隔表头与其他行写法1234| 名字 | 性别 | 年龄 || ---- | ---- | --- || 张三 | 男 | 18 || 赵淑芬 | 女 | 20 |效果 名字 性别 年龄 张三 男 18 赵淑芬 女 20 注意：为了使 Markdown 更清晰，| 和 - 两侧需要至少有一个空格（最左侧和最右侧的 | 外不需要） 如果想改变表格的对齐方式：需要在表头下方的分割线标记中加入 ：此外，表格中可以放其他的markdown的标记 :— 代表左对齐 :–: 代表居中对齐 —: 代表右对齐 默认是左对齐写法1234| 名字 | 性别 | 年龄 || ----: | :----: | :--- || 张三 | 男 | 18 || 赵淑芬 | 女 | 20 | 效果 名字 性别 年龄 张三 男 18 赵淑芬 女 20 hexo 的标签语法hexo 为了显示的效果更好，自身定义了一些标签插件，hexo中文文档链接 引用块123&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content&#123;% endblockquote %&#125; 普通的引用在blockquote后面不写任何参数，就只是单纯的引用，效果与使用&gt;一样 对书上语言的引用123&#123;% blockquote 作者, 出处 %&#125;xxxxxxxxxxxxxxxxxxxxxxxxxxxx&#123;% endblockquote %&#125; 黑夜无论怎样悠长，白昼总会到来。 莎士比亚麦克白 对网络上的引用123&#123;% blockquote @作者 网络地址 %&#125;xxxxxxxxxxxxxxxxxxxxxxxxxx&#123;% endblockquote %&#125; 有时候，“爱国”，是一个空洞的词语。更多的人是在言语里，在诗歌里”爱国“，他们没有一点点实际行动，甚至充满抱怨。 @余秀华blog.sina.com.cn/yuxiuhua1976 代码块123&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;code snippet&#123;% endcodeblock %&#125; 普通代码块在codeblock不加任何参数的标签，和使用`（单行的时候使用）以及` ` `（多行的时候使用）效果一样123&#123;% codeblock %&#125;console.log(&quot;我叫丰木木&quot;)&#123;% endcodeblock %&#125; 1console.log(&quot;我叫丰木木&quot;) 带有使用语言的代码块（有高亮）123&#123;% codeblock lang:JavaScript %&#125;console.log(&quot;我叫丰木木&quot;)&#123;% endcodeblock %&#125; 1console.log("我叫丰木木") 带有说明的代码块123&#123;% codeblock js控制台输出语句 %&#125;console.log(&quot;我叫丰木木&quot;)&#123;% endcodeblock %&#125; 控制台输出语句1console.log(&quot;我叫丰木木&quot;) 附带有说明网址的代码块123&#123;% codeblock 控制台输出语句 https://developer.mozilla.org/zh-CN/docs/Web/API/Console/log 查看MDN相关解释%&#125;console.log(&quot;我叫丰木木&quot;)&#123;% endcodeblock %&#125; 控制台输出语句查看MDN相关解释1console.log(&quot;我叫丰木木&quot;) 反引号代码块使用``` [title] [lang:language] [url] [link text] ``` 一样可以使用以上几个标签效果注意：反引号代码块后面的参数 在本博客环境下实测没有效果，也就是说使用`是可以当做普通代码块使用 插入iframe1&#123;% iframe url [width] [height] %&#125; 插入image1&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125; 插入Include Code插入source文件夹中的代码文件1&#123;% include_code [title] [lang:language] path/to/file %&#125; next中的标签next文档中文传门 文本居中123456789&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;&lt;!-- 其中 class=&quot;blockquote-center&quot; 是必须的 --&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;blah blah blah&lt;/blockquote&gt;&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125;&lt;!-- 标签别名 --&gt;&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125; 当我看到人和草木一样生长繁衍，任凭同一个老天他们鼓励阻拦。青春时蓬蓬勃勃，全盛时又该走向凋落，繁华和璀璨都将从记忆中消散。——Shakespeare 《莎士比亚十四行诗》 插入的图片变大使用方式 HTML方式：使用这种方式时，为 img 添加属性 class=”full-image”即可。 标签方式：使用 fullimage 或者 简写 fi， 并传递图片地址、 alt 和 title 属性即可。 属性之间以逗号分隔。突破容器宽度限制的图片文档链接1234567891011&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;&lt;!-- 其中 class=&quot;full-image&quot; 是必须的 --&gt;&lt;img src=&quot;/image-url&quot; class=&quot;full-image&quot; /&gt;&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;/image-url&quot; class=&quot;full-image&quot; alt=&quot;alt&quot; title=&quot;title&quot; /&gt;&lt;meta itemprop=&quot;width&quot; content=&quot;auto&quot;&gt;&lt;meta itemprop=&quot;height&quot; content=&quot;auto&quot;&gt;&lt;/span&gt;&lt;!-- 别名 --&gt;&lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;/image-url&quot; class=&quot;full-image&quot; alt=&quot;alt&quot; title=&quot;title&quot; /&gt;&lt;meta itemprop=&quot;width&quot; content=&quot;auto&quot;&gt;&lt;meta itemprop=&quot;height&quot; content=&quot;auto&quot;&gt;&lt;/span&gt; Bootstrap Callout123&#123;% note class_name %&#125; xxxxxxxxxxxxxxxxxxx &#123;% endnote %&#125; class_name 数值可以为 default primary success info warning danger]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个文件]]></title>
    <url>%2F2018%2F06%2F28%2Ffist%20document%2F</url>
    <content type="text"><![CDATA[第一个文件浪费了大半天，试着用hexo在github上建了一个博客，就一个感觉：小屏幕太毁眼睛了目前先这样后期有如下安排 熟悉hexo 修改目前正在使用的appollo模版 写学习笔记]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
